/*
 * FreeModbus Libary: BARE Port
 * Copyright (C) 2006 Christian Walter <wolti@sil.at>
  */

/* ----------------------- Platform includes --------------------------------*/
#include <stdlib.h>
#include "port.h"

/* ----------------------- Modbus includes ----------------------------------*/
#include "mb.h"
#include "mbport.h"

/* ----------------------- Static variables ---------------------------------*/
static UCHAR xOriginalState;
static ULONG ulNesting;

static eMBEventType eQueuedEvent;
static BOOL xEventInQueue;

/* ----------------------- Enable USART interrupts -----------------------------*/
void vMBPortSerialEnable(BOOL xRxEnable, BOOL xTxEnable)
{
	/* If xRXEnable enable serial receive interrupts. If xTxENable enable
	 * transmitter empty interrupts.
	 */
	if (xRxEnable)
	{
		usart_enable_rx_interrupt(MB_USART );
	} else
	{
		usart_disable_rx_interrupt(MB_USART );
	}

	if (xTxEnable)
	{
		usart_enable_tx_interrupt(MB_USART );
	} else
	{
		usart_disable_tx_interrupt(MB_USART );
	}
}

/* ----------------------- Initialize USART ----------------------------------*/
/* Called with databits = 8 for RTU */

BOOL xMBPortSerialInit(UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity)
{
	BOOL bStatus;

	gpio_mode_setup(PORT(MB_USART_TX_PIN ), GPIO_MODE_AF, GPIO_PUPD_NONE, PIN(MB_USART_TX_PIN ) );
	gpio_set_af(PORT(MB_USART_TX_PIN ), GPIO_AF0, PIN(MB_USART_TX_PIN ) );
	gpio_mode_setup(PORT(MB_USART_RX_PIN ), GPIO_MODE_AF, GPIO_PUPD_NONE, PIN(MB_USART_RX_PIN ) );
	gpio_set_af(PORT(MB_USART_RX_PIN ), GPIO_AF0, PIN(MB_USART_RX_PIN ) );

	rcc_periph_clock_enable(MB_USART_RCC );
	nvic_enable_irq(MB_NVIC_USART_IRQ );

	/* Setup UART parameters. */
	usart_set_baudrate(MB_USART, ulBaudRate );
	usart_set_stopbits(MB_USART, USART_STOPBITS_1 );
	usart_set_flow_control(MB_USART, USART_FLOWCONTROL_NONE );
	usart_set_mode(MB_USART, USART_MODE_TX_RX );
	bStatus = TRUE;
	switch (eParity)
	{
		case MB_PAR_NONE:
			usart_set_parity(MB_USART, USART_PARITY_NONE );
			break;
		case MB_PAR_ODD:
			usart_set_parity(MB_USART, USART_PARITY_ODD );
			break;
		case MB_PAR_EVEN:
			usart_set_parity(MB_USART, USART_PARITY_EVEN );
			break;
		default:
			bStatus = FALSE;
			break;
	}

	/* Oddity of STM32F series: word length includes parity. 7 bits no parity
	 not possible */
	CHAR wordLength;
	switch (ucDataBits)
	{
		case 8:
			if (eParity == MB_PAR_NONE) wordLength = 8;
			else wordLength = 9;
			usart_set_databits(MB_USART, wordLength );
			break;
		case 7:
			if (eParity == MB_PAR_NONE) bStatus = FALSE;
			else usart_set_databits(MB_USART, 8 );
			break;
		default:
			bStatus = FALSE;
	}

	if (bStatus == TRUE)
	{
		/* Finally enable the USART. */
		usart_disable_rx_interrupt(MB_USART );
		usart_disable_tx_interrupt(MB_USART );
		usart_enable(MB_USART );
	}
	return bStatus;
}

/* -----------------------Send character  ----------------------------------*/
BOOL xMBPortSerialPutByte(CHAR ucByte)
{
	/* Put a byte in the UARTs transmit buffer. This function is called
	 * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been
	 * called. */
	usart_send(MB_USART, ucByte );
	return TRUE;
}

/* ----------------------- Get character ----------------------------------*/
BOOL xMBPortSerialGetByte(CHAR *pucByte)
{
	/* Return the byte in the UARTs receive buffer. This function is called
	 * by the protocol stack after pxMBFrameCBByteReceived( ) has been called.
	 */
	*pucByte = (CHAR) usart_recv(MB_USART );
	return TRUE;
}

/* ----------------------- Close Serial Port ----------------------------------*/
void vMBPortSerialClose(void)
{
	nvic_disable_irq(MB_NVIC_USART_IRQ );
	usart_disable(MB_USART );
}

/* ----------------------- USART ISR ----------------------------------*/
/* Create an interrupt handler for the transmit buffer empty interrupt
 * (or an equivalent) for your target processor. This function should then
 * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that
 * a new character can be sent. The protocol stack will then call 
 * xMBPortSerialPutByte( ) to send the character.
 */
/* Find out what interrupted and get or send data as appropriate *
 void MB_USART_ISR(void)
 {
 /* Check if we were called because of RXNE.
 if (usart_get_flag(MB_USART, USART_SR_RXNE ))
 {
 pxMBFrameCBByteReceived(  );
 }
 /* Check if we were called because of TXE.
 if (usart_get_flag(MB_USART, USART_SR_TXE ))
 {
 pxMBFrameCBTransmitterEmpty(  );
 }
 }
 */

void MB_USART_ISR(void)
{
	// Read data register not empty flag
	if (usart_get_flag(MB_USART, USART_SR_RXNE ))
	{
		pxMBFrameCBByteReceived();
	}
	//   Transmit data register empty flag
	if (usart_get_flag(MB_USART, USART_SR_TXE ))
	{
		pxMBFrameCBTransmitterEmpty();
	}
	// Receiver timeout flag
	if (usart_get_flag(MB_USART, USART_ISR_RTOF ))
	{
		USART_ICR(MB_USART) |= USART_ICR_RTOCF;
		pxMBPortCBTimerExpired();
	}
}

/* ----------------------- Initialize Timer -----------------------------*/
BOOL xMBPortTimersInit(USHORT usTim1Timerout50us)
{

	usart_set_rx_timeout_value(MB_USART, 35 );
//	usart_enable_rx_timeout(MB_USART);
//	usart_enable_rx_timeout_interrupt(MB_USART);
//	timer_set_period(MB_TIMER, usTim1Timerout50us);	// 50 microseconds period
	return TRUE;
}

/* ----------------------- Enable Timer -----------------------------*/
inline void vMBPortTimersEnable()
{
	usart_enable_rx_timeout(MB_USART );
	usart_enable_rx_timeout_interrupt(MB_USART );

}

/* ----------------------- Disable timer -----------------------------*/
inline void vMBPortTimersDisable()
{
	usart_disable_rx_timeout(MB_USART );
	usart_disable_rx_timeout_interrupt(MB_USART );
}

void vMBPortTimersDelay(USHORT usTimeOutMS)
{

}

/* ----------------------- Cortex-M3 PRIMASK enable/disable -----------------*/
/* Gregory Nutt <spudmonkey@racsa.co.cr> */

/* Get/set the primask register to control global DI/EI*/

static inline uint8_t getprimask(void)
{
	uint32_t primask;
	__asm__ __volatile__
	(
			"\tmrs  %0, primask\n"
			: "=r" (primask)
			:
			: "memory");
	return (uint8_t) primask;
}

static inline void setprimask(uint32_t primask)
{
	__asm__ __volatile__
	(
			"\tmsr primask, %0\n"
			:
			: "r" (primask)
			: "memory");
}
/* ----------------------- Critical Section handler -----------------------------*/
/* Check if PRIMASK was set, and disable it on entry. On exit, if it was originally
 set then set it back again otherwise leave it unset. */
void vMBPortEnterCritical(void)
{
	if (ulNesting == 0)
	{
		xOriginalState = getprimask();
	}
	ulNesting++;
	setprimask(1 );
}

void vMBPortExitCritical(void)
{
	ulNesting--;
	if (ulNesting == 0)
	{
		setprimask(xOriginalState );
	}
}

/* ----------------------- Close Ports -----------------------------*/
void vMBPortClose(void)
{
	extern void vMBPortSerialClose(void);
	extern void vMBPortTimersDisable(void);
	vMBPortSerialClose();
	vMBPortTimersDisable();
}

/* ----------------------- Start implementation -----------------------------*/
BOOL xMBPortEventInit(void)
{
	xEventInQueue = FALSE;
	return TRUE;
}

BOOL xMBPortEventPost(eMBEventType eEvent)
{
	xEventInQueue = TRUE;
	eQueuedEvent = eEvent;
	return TRUE;
}

BOOL xMBPortEventGet(eMBEventType *eEvent)
{
	BOOL xEventHappened = FALSE;

	if (xEventInQueue)
	{
		*eEvent = eQueuedEvent;
		xEventInQueue = FALSE;
		xEventHappened = TRUE;
	}
	return xEventHappened;
}

